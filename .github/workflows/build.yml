name: Build ImmortalWrt Docker Image

on:
  workflow_dispatch:
    inputs:
      kernel_version:
        description: 'Select Clash Meta Kernel Version'
        required: true
        default: 'v3-smart'
        type: choice
        options:
          - v1
          - v2
          - v3
          - v1-smart
          - v2-smart
          - v3-smart

env:
  # 固件版本与架构
  IM_VERSION: "24.10.1"
  TARGET_BOARD: "x86"
  TARGET_SUBTARGET: "64"
  # 镜像名称
  IMAGE_NAME: "immortalwrt-openclash"
  # OpenClash 仓库
  OPENCLASH_REPO: "vernesong/OpenClash"

jobs:
  build:
    runs-on: ubuntu-22.04
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Initialize Environment
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          sudo -E apt-get -y update
          sudo -E apt-get -y install build-essential libncurses5-dev libncursesw5-dev \
            zlib1g-dev gawk git gettext libssl-dev xsltproc rsync wget unzip python3 qemu-utils zstd

      - name: Smart Download ImageBuilder
        run: |
          # 1. 设定基础目录 URL
          BASE_URL="https://downloads.immortalwrt.org/releases/${IM_VERSION}/targets/${TARGET_BOARD}/${TARGET_SUBTARGET}"

          # 2. 下载 sha256sums 校验文件
          echo "Fetching sha256sums to detect filename..."
          wget -O sha256sums "$BASE_URL/sha256sums"

          if [ ! -f sha256sums ]; then
            echo "Error: Failed to fetch sha256sums. Check version info."
            exit 1
          fi

          # 3. 提取 ImageBuilder 文件名 (适配 .tar.xz 或 .tar.zst)
          # 逻辑：查找包含 imagebuilder 和 Linux-x86_64 的行
          # 修复：使用 tr -d '*' 删除星号，比 sed 更安全
          IB_FILENAME=$(grep "imagebuilder" sha256sums | grep "Linux-x86_64" | head -n 1 | awk '{print $2}' | tr -d '*')

          if [ -z "$IB_FILENAME" ]; then
            echo "Error: ImageBuilder filename not found in sha256sums."
            exit 1
          fi

          echo "Detected ImageBuilder: $IB_FILENAME"

          # 4. 下载并解压
          wget -O imagebuilder.tar "$BASE_URL/$IB_FILENAME"

          mkdir -p imagebuilder
          if [[ "$IB_FILENAME" == *".zst" ]]; then
            tar -I zstd -xf imagebuilder.tar -C imagebuilder --strip-components=1
          else
            tar -xf imagebuilder.tar -C imagebuilder --strip-components=1
          fi

      - name: Prepare Clash Kernel
        run: |
          # 创建存放内核的目录
          mkdir -p imagebuilder/files/etc/openclash/core

          KERNEL_OPT="${{ inputs.kernel_version }}"
          BASE_URL="https://raw.githubusercontent.com/vernesong/OpenClash/core/master"

          # 构造下载链接
          if [[ "$KERNEL_OPT" == *"-smart"* ]]; then
            # 提取 v1/v2/v3
            VER=${KERNEL_OPT%-smart}
            DOWNLOAD_URL="${BASE_URL}/smart/clash-linux-amd64-${VER}.tar.gz"
          else
            DOWNLOAD_URL="${BASE_URL}/meta/clash-linux-amd64-${KERNEL_OPT}.tar.gz"
          fi

          echo "Downloading Kernel: $DOWNLOAD_URL"
          wget -O kernel.tar.gz "$DOWNLOAD_URL"

          # 解压并重命名为 clash_meta
          tar -xzf kernel.tar.gz
          mv clash* imagebuilder/files/etc/openclash/core/clash_meta
          chmod +x imagebuilder/files/etc/openclash/core/clash_meta

      - name: Download Latest OpenClash
        run: |
          mkdir -p imagebuilder/packages/custom

          echo "Fetching OpenClash release info..."

          # 1. 使用 /releases 接口以获取列表 (包含 Pre-release/Beta)
          # 2. 添加 GitHub Token 避免 API 限流
          # 3. 提取第一个(最新的)包含 luci-app-openclash 和 .ipk 的下载链接
          OC_URL=$(curl -sL -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            "https://api.github.com/repos/${OPENCLASH_REPO}/releases" | \
            grep "browser_download_url" | \
            grep "luci-app-openclash" | \
            grep ".ipk" | \
            head -n 1 | \
            cut -d '"' -f 4)

          # 增加空值检查
          if [ -z "$OC_URL" ]; then
            echo "Error: Failed to extract OpenClash download URL."
            echo "Possible reasons: API rate limit exceeded, or no IPK found in the latest release."
            exit 1
          fi

          echo "Downloading OpenClash from: $OC_URL"
          wget -P imagebuilder/packages/custom "$OC_URL"

      - name: Generate Rootfs
        working-directory: ./imagebuilder
        run: |
          # 读取 packages.txt (去除注释和空行)
          PACKAGES_LIST=$(grep -vE '^\s*#' ../packages.txt | tr '\n' ' ')

          # 构建 rootfs
          make image PROFILE="generic" PACKAGES="$PACKAGES_LIST" FILES="files"

      - name: Prepare Docker Context
        run: |
          # 提取 rootfs.tar.gz
          find imagebuilder/bin/targets/${TARGET_BOARD}/${TARGET_SUBTARGET} -name "*rootfs.tar.gz" -exec mv {} ./rootfs.tar.gz \;

          if [ ! -f rootfs.tar.gz ]; then
            echo "Error: rootfs.tar.gz not found!"
            exit 1
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push
        run: |
          # 生成时间戳 (YYYYMMDDHHMM) - 使用 UTC+8 (北京/台北时间)
          DATE_TAG=$(TZ='Asia/Shanghai' date +%Y%m%d%H%M)

          # 转换为小写
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          FULL_IMAGE_NAME="ghcr.io/${REPO_OWNER}/${IMAGE_NAME}"

          echo "Pushing tags:"
          echo "  - ${FULL_IMAGE_NAME}:${DATE_TAG}"
          echo "  - ${FULL_IMAGE_NAME}:latest"

          docker buildx build \
            --platform linux/amd64 \
            --tag "${FULL_IMAGE_NAME}:${DATE_TAG}" \
            --tag "${FULL_IMAGE_NAME}:latest" \
            --file docker/Dockerfile \
            --push \
            .